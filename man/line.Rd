% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/line.R
\name{line}
\alias{line}
\title{Line Algorithm for Graph Embedding}
\usage{
line(df = NULL, binary = 0, dim = 100, order = 2, negative = 5,
  samples = 1, rho = 0.025, threads = 1)
}
\arguments{
\item{df}{edge list representation of the graph in the form u, v, w. Three columns 
are in this dataframe. The edges are directed which means edge u -> v has weight w. 
To represent an undirected graph just input edges u, v, w and v, u, w.
The first column and second column represent the u and v vertices with 
character types. The third column represented the weight of the edges. Each row 
represents a weighted edge in the graph.}

\item{binary}{Save the learnt embeddings in binary moded; This should always be 0
because R cannot represent binary formats}

\item{dim}{Set dimension of vertex embeddings. Default is 100}

\item{order}{The type of model we want, 1 for first order, 2 for second order. Default
is 2}

\item{negative}{Number of negative samples. Default is 5}

\item{samples}{Set the number of training samples as k million. Default is 1 (million)}

\item{rho}{Set the start learning rate. default is 0.025}

\item{threads}{Use how many # of threads. Default is 1}
}
\value{
a numeric matrix of order 1 or 2. Input two numeric matrixes of different order
into concatenate to get a fully represented graph embedding. 
This embedded graph has row names as vertices. Each row is a set of weights describing the
row name/feature/vertice.
}
\description{
This function runs the line algorithm on your reconstructed edge list graph and returns a  
numeric matrix. Each row represents one vertice of the embedded graph with the row name 
being the name of the vertice. Each row has a list of weights (all numeric values) 
all describing the row vertice.
}
\details{
This is a function which takes a graph represented in edge list form as input.  
The edge list should be represented as a dataframe with the edges in the form of u, v, w.
This dataframe should be generated by the reconstruct function.  
u, v are the vertice names and are turned into StringVectors in Rcpp. w is the 
edge weight and is transformed into a numeric vector in Rcpp.
This function then calls the original line algorithm written in C++. Too
gain a better understanding of what each parameter does please look at the 
the line paper in references and the implementation in the github link.
An important parameter is that you can run this algorithm on multiple threads 
to speed up the runtime. The results are not deterministic if you run this algorithm 
for more than one thread. Another important parameter is that you can train the line algorithm
on two orders, order 1 and order 2 which return different numeric matrices 
for the same graph input. There are other parameters which determine the amount of sampling, 
negative sampling, learning rate, etc. of the algorithm which you should look into.
This function returns a reduced graph represented in the form of a numeric matrix.
This numeric matrix has row names describing the vertices with each vertice  
This reconstructed graph can be passed into line to run the main line algorithm for 
graph embedding
}
\examples{
u <- c("good", "the", "bad")
v <- c("the", "good", "the")
w <- 1:3
df <- data.frame(u, v, w)
new_df <- reconstruct(df)
order_1 <- line(df = new_df, binary = 0, dim = 100, order = 1, negative = 5, samples = 10, rho = 0.025, threads = 1)
order_2 <- line(df = new_df, binary = 0, dim = 100, order = 2, negative = 5, samples = 10, rho = 0.025, threads = 1) 
}
\references{
\url{https://arxiv.org/abs/1503.03578}
}
\seealso{
\url{https://github.com/tangjianpku/LINE}
}
