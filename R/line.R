#' @title Reconstruct Graph 
#'
#' @description  
#' This function reconstructs your edge list graph into another condensed edge 
#' list graph which you can run the line algorithm on. 
#' 
#' @details 
#' This is a function which takes a graph represented in edge list form as input. 
#' The edge list should be represented as a dataframe with the edges in the form of u, v, w. 
#' u, v are the vertice names and are turned into StringVectors in Rcpp. w is the 
#' edge weight and is transformed into a numeric vector in Rcpp.
#' This function then calls the original line algorithm written in C++. Too
#' gain a better understanding of what each parameter does please look at the 
#' the line paper in references and the implementation in the github link.
#' This function returns a reconstructed graph as a dataframe in the form u, v, w.
#' This reconstructed graph can be passed into line to run the main line algorithm for 
#' graph embedding
#'
#' @param df edge list representation of the graph in the form u, v, w. Three columns 
#' are in this dataframe. The edges are directed which means edge u -> v has weight w. 
#' To represent an undirected graph just input edges u, v, w and v, u, w.
#' The first column and second column represent the u and v vertices with 
#' character types. The third column represented the weight of the edges. Each row 
#' represents a weighted edge in the graph.
#' @param max_depth The maximum depth in the Breadth-First-Search. Default is 1, never input 0.
#' @param max_k For vertex whose degree is less than max_k, we will expand its neighbors 
#' until the degree reaches max_k
#' @return a reconstructed graph that can be inputted directly into the line function. 
#' This graph is represented in edge list form in an identical format as the input 
#' parameter df. Note it is also a directed edge list.
#'
#' @seealso 
#'  \url{https://github.com/tangjianpku/LINE}
#' @references 
#'  \url{https://arxiv.org/abs/1503.03578}
#'   
#' @examples
#' u <- c("good", "the", "bad")
#' v <- c("the", "good", "the")
#' w <- 1:3
#' df <- data.frame(u, v, w)
#' reconstruct(df)
#' reconstruct(df, max_depth = 2)
#' reconstruct(df, max_depth = 2, max_k = 2)
reconstruct <- function(df, max_depth = 1, max_k = 0) {
  return(reconstruct_caller(as.character(df[, 1]), as.character(df[, 2]), as.numeric(df[, 3]), max_depth, max_k))
}

#' @title Line Algorithm for Graph Embedding
#'
#' @description  
#' This function runs the line algorithm on your reconstructed edge list graph and returns a  
#' numeric matrix. Each row represents one vertice with the row name being the name of the vertice
#' The row has a list of weights (all numeric values) all describing the row feature/name
#'
#' @details 
#' This is a function which takes a graph represented in edge list form as input.  
#' The edge list should be represented as a dataframe with the edges in the form of u, v, w.
#' This dataframe should be generated by the reconstruct function.  
#' u, v are the vertice names and are turned into StringVectors in Rcpp. w is the 
#' edge weight and is transformed into a numeric vector in Rcpp.
#' This function then calls the original line algorithm written in C++. Too
#' gain a better understanding of what each parameter does please look at the 
#' the line paper in references and the implementation in the github link.
#' An important parameter is that you can run this algorithm on multiple threads 
#' to speed up the runtime. The results are not deterministic if you run this algorithm 
#' for more than one thread. Another important parameter is that you can train the line algorithm
#' on two orders, one and two which return different numeric matrices for the same graph input.
#' This function returns a reduced graph represented in the form of a numeric matrix.
#' This numeric matrix has row names describing the vertices with each vertice  
#' This reconstructed graph can be passed into line to run the main line algorithm for 
#' graph embedding
#'
#' @param df edge list representation of the graph in the form u, v, w. Three columns 
#' are in this dataframe. The edges are directed which means edge u -> v has weight w. 
#' To represent an undirected graph just input edges u, v, w and v, u, w.
#' The first column and second column represent the u and v vertices with 
#' character types. The third column represented the weight of the edges. Each row 
#' represents a weighted edge in the graph.
#' @param binary Save the learnt embeddings in binary moded; This should always be 0
#'  because R cannot represent binary formats
#' @param dim Set dimension of vertex embeddings. Default is 100
#' @param order The type of model we want, 1 for first order, 2 for second order. Default
#' is 2
#' @param negative Number of negative samples. Default is 5
#' @param samples Set the number of training samples as k million. Default is 1 (million)
#' @param threads Use how many # of threads. Default is 1
#' @param rho Set the start learning rate. default is 0.025
#' @return a numeric matrix of order 1 or 2. Input two numeric matrixes of different order
#' into concatenate to get a fully represented graph embedding. 
#' This embedded graph has row names as vertices. Each row is a set of weights describing the
#' row name/feature/vertice. 
#'
#' @seealso 
#'  \url{https://github.com/tangjianpku/LINE}
#' @references 
#'  \url{https://arxiv.org/abs/1503.03578}
#'   
#' @examples
#' u <- c("good", "the", "bad")
#' v <- c("the", "good", "the")
#' w <- 1:3
#' df <- data.frame(u, v, w)
#' new_df <- reconstruct(df)
#' order_1 <- line(df = new_df, binary = 0, dim = 100, order = 1, negative = 5, samples = 10, rho = 0.025, threads = 1)
#' order_2 <- line(df = new_df, binary = 0, dim = 100, order = 2, negative = 5, samples = 10, rho = 0.025, threads = 1) 
line <- function(df = NULL, binary = 0, dim = 100, order = 2, negative = 5, samples = 1, rho = 0.025, threads = 1) {
  return(line_caller(as.character(df[, 1]), as.character(df[, 2]), as.numeric(df[, 3]), binary, dim, order, negative, samples, rho, threads))
}

#' @title Concatenate Two Graph Embeddings
#'
#' @description  
#' This function concatenates two graph embeddings represented as numeric matrixes returned by 
#' line
#'
#' @details 
#' This function concatenates two graph embeddings represented as numeric matrixes of differnet
#' orders. It takes two numeric matrixes returned by line after calling line with the same input
#' dataframe but different orders (1 and 2). It returns a combined graph embedding represented 
#' as a numeric matrix with row names representing the vertice. Each row is a 
#' weight of the row name/feature/vertice.
#'
#' @param input_one the first numeric matrix returned by line. This should have a 
#' different order than input_two
#' @param input_two the second numeric matrix returned by line. This should have a 
#' different order than input_one
#' @param binary This should always be zero as we don't want a binary formatted dataframe. default is#'  0
#'
#' @seealso 
#'  \url{https://github.com/tangjianpku/LINE}
#' @references 
#'  \url{https://arxiv.org/abs/1503.03578}
#'   
#' @examples
#' u <- c("good", "the", "bad")
#' v <- c("the", "good", "the")
#' w <- 1:3
#' df <- data.frame(u, v, w)
#' new_df <- reconstruct(df)
#' order_1 <- line(df = new_df, binary = 0, dim = 100, order = 1, negative = 5, samples = 10, rho = 0.025, threads = 1)
#' order_2 <- line(df = new_df, binary = 0, dim = 100, order = 2, negative = 5, samples = 10, rho = 0.025, threads = 1) 
#' concatenate_df <- concatenate(input_one = order_1, input_two = order_2, binary = 0)
concatenate <- function(input_one, input_two, binary = 0) {
  return(concatenate_caller(input_one, input_two, rownames(input_one), rownames(input_two), binary))
}

#' @title 
#'
#' @description  
#' This function concatenates two graph embeddings represented as numeric matrixes of differnet
#' orders. It takes two numeric matrixes returned by line after calling line with the same input
#' but different order (1 and 2). It returns a combined graph embedding represented as a numeric
#' matrix with row names representing the vertice. Each row is a weight of the row name/feature/
#' vertice.
#'
#' @details 
#' to speed up the runtime. The results are not deterministic if you run this algorithm 
#' for more than one thread. Another important parameter is that you can train the line algorithm
#' on two orders, one and two which return different numeric matrices for the same graph input.
#' This function returns a reduced graph represented in the form of a numeric matrix.
#' This numeric matrix has row names describing the vertices with each vertice  
#' This reconstructed graph can be passed into line to run the main line algorithm for 
#' graph embedding
#'
#' @param df edge list representation of the graph in the form u, v, w. Three columns 
#' are in this dataframe. The edges are directed which means edge u -> v has weight w. 
#' To represent an undirected graph just input edges u, v, w and v, u, w.
#' The first column and second column represent the u and v vertices with 
#' character types. The third column represented the weight of the edges. Each row 
#' represents a weighted edge in the graph.
#' @param binary Save the learnt embeddings in binary moded; This should always be 0
#'  because R cannot represent binary formats
#' @param dim Set dimension of vertex embeddings. Default is 100
#' @param order The type of model we want, 1 for first order, 2 for second order. Default
#' is 2
#' @param negative Number of negative samples. Default is 5
#' @param samples Set the number of training samples as k million. Default is 1 (million)
#' @param threads Use how many # of threads. Default is 1
#' @param rho Set the start learning rate. default is 0.025
#' @return a numeric matrix of order 1 or 2. Input two numeric matrixes of different order
#' into concatenate to get a fully represented graph embedding. 
#' This embedded graph has row names as vertices. Each row is a set of weights describing the
#' row name/feature/vertice. 
#'
#' @seealso 
#'  \url{https://github.com/tangjianpku/LINE}
#' @references 
#'  \url{https://arxiv.org/abs/1503.03578}
#'   
#' @examples
#' u <- c("good", "the", "bad")
#' v <- c("the", "good", "the")
#' w <- 1:3
#' df <- data.frame(u, v, w)
#' new_df <- reconstruct(df)
#' order_1 <- line(df = new_df, binary = 0, dim = 100, order = 1, negative = 5, samples = 10, rho = 0.025, threads = 1)
#' order_2 <- line(df = new_df, binary = 0, dim = 100, order = 2, negative = 5, samples = 10, rho = 0.025, threads = 1) 
#' concatenate_df <- concatenate(input_one = order_1, input_two = order_2, binary = 0)
#' normalize_df <- normalize(input_matrix = normalize_df)
normalize <- function(input_matrix) {
  return(input_matrix / sqrt(rowSums(input_matrix * input_matrix)))
}
